<!DOCTYPE html>
<html lang="en">
	<head>
		<title></title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener"></a>
		</div>

		<script type="x-shader/x-vertex" id="sem-vs">

      varying vec2 vN;

      void main() {

        vec3 e = normalize( vec3( modelViewMatrix * vec4( position, .5 ) ) );
        vec3 n = normalize( normalMatrix * normal );

        vec3 r = reflect( e, n );
        float m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );
        vN = r.xy / m + .5;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );

      }

    </script>

    <script type="x-shader/x-vertex" id="sem-fs">

      uniform sampler2D tMatCap;

      varying vec2 vN;

      void main() {

        vec3 base = texture2D( tMatCap, vN ).rgb;
        gl_FragColor = vec4( base, 1.0 );

      }

    </script>


		<script type="module">

			import * as THREE from '/build/three.module.js';
			import { OrbitControls } from '/examples/jsm/controls/OrbitControls.js';
			import { Reflector } from '/examples/jsm/objects/Reflector.js';
			import { RGBELoader } from '/examples/jsm/loaders/RGBELoader.js';

			import { GUI } from '/examples/jsm/libs/dat.gui.module.js';
			import { RectAreaLightUniformsLib } from '/examples/jsm/lights/RectAreaLightUniformsLib.js';

			
			// scene size
			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

			var SHADOW_MAP_WIDTH = WIDTH, SHADOW_MAP_HEIGHT = HEIGHT;

			// camera
			var VIEW_ANGLE = 35;
			var ASPECT = WIDTH / HEIGHT;
			var NEAR = 1;
			var FAR = 25000;

			var camera, scene, renderer, light1, cube;

			var mouseX = 0, mouseY = 0;

			var y1=0;

			var x1 = 0;
  			var z1 =0;

  			var new_texture;

  			var windowHalfX = window.innerWidth / 2;
      		var windowHalfY = window.innerHeight / 2;

			//new code
			var material_new;
			var dirLight;

			var count = 0, cubeCamera, cubeRenderTarget;

			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;
			var mouseXOnMouseDown = 0;
			
			
			var group;
			var cylinder10;
			var cylinder9;
			var cylinder8;
			var cylinder7;
			var cylinder6;
			var cylinder5;
			var cylinder4;
			var cylinder3;
			var cylinder2;
			var cylinder1;
			var cylinder;
			var counter = 0;
			var list;
			var colorlist;

			var twisted_geometry;


			init();
			animate();

			////////////

			function init() {

			  		// scene
					scene = new THREE.Scene();

					document.addEventListener( 'mousemove', onDocumentMouseMove, false )
		            document.addEventListener( 'wheel', onDocumentWheel, false );
		            // document.addEventListener( 'mousedown', onDocumentMouseDown, false );
					// document.addEventListener( 'touchstart', onDocumentTouchStart, false );
					// document.addEventListener( 'touchmove', onDocumentTouchMove, false );
					document.addEventListener( 'click', onDocumentMouseClick);
					var container = document.getElementById( 'container' );

					// renderer
					renderer = new THREE.WebGLRenderer( { antialias: true } );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( WIDTH, HEIGHT );
					container.appendChild( renderer.domElement );
					renderer.setClearColor('#8F6235');
					renderer.shadowMap.enabled = true;
	        		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

					// camera
					camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
					// camera.position.set( 0, 75, 160 );
					camera.position.z = 2300;
	        		camera.position.y = 1000;

	    //     		group = new THREE.Group();
					// group.position.y = 50;
					// scene.add( group );
	        		
	    //     		var controls = new OrbitControls( camera, renderer.domElement );
					// controls.minDistance = 2000;
					// controls.maxDistance = 3000;

	        		var fogs = [
			          0xBDE3F4,
			          0x1A1F21,
			          0xf2eedd
			        ]

	        		scene.fog = new THREE.Fog( 0xFFFFFF, 1, 25000 );

        			//LIGHTS

        		  	light1 = new THREE.SpotLight( 0xffffff, 0.3, 0, Math.PI / 2 );
			        light1.position.set( 2000, 4000, -3000 );
			        light1.target.position.set( 1, 1, 1 );

			  

			        light1.castShadow = true;

			        light1.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 20, 10, 100, 20000 ) );
			        light1.shadow.bias = 0.0001;
			        light1.shadow.camera.near = NEAR;
			        light1.shadow.camera.far = FAR;
			        light1.shadow.camera.fov = 15;

			        light1.shadow.mapSize.width = SHADOW_MAP_WIDTH;
			        light1.shadow.mapSize.height = SHADOW_MAP_HEIGHT;

			        light1.shadow.camera.right    =  50000;
			        light1.shadow.camera.left     = -50000;
			        light1.shadow.camera.top      =  50000;
			        light1.shadow.camera.bottom   = -50000;

			        var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.8 );
				    hemiLight.position.set( 100, 500, 0 );
				    scene.add( hemiLight );

				    dirLight = new THREE.DirectionalLight( 0xffffff, 0.4 );
			        //dirLight.color.setHSL( 0.1, 1, 0.95 );
			        dirLight.position.set( -3000, 4000, 3000 );
			        //dirLight.position.multiplyScalar( 50 );

			    
			        scene.add( dirLight );

			        dirLight.castShadow = true;

			        dirLight.shadow.mapSize.width = 3048;
			        dirLight.shadow.mapSize.height = 3048;

			        var d = 1500;

			        dirLight.shadow.camera.left = -d;
			        dirLight.shadow.camera.right = d;
			        dirLight.shadow.camera.top = d;
			        dirLight.shadow.camera.bottom = -d;
			        dirLight.shadow.camera.near = 40;
			        dirLight.shadow.camera.far = 10000;
			        dirLight.shadow.bias = 0.00001;
			        dirLight.shadow.darkness = 0.2;

			     	// Cube_texture
			    	var path = "examples/textures/cube/skyboxsun25deg/";
		        	var format = '.jpg';
		        	var urls = [
		            path + 'px' + format, path + 'nx' + format,
		            path + 'py' + format, path + 'ny' + format,
		            path + 'pz' + format, path + 'nz' + format
		          ];


					var reflectionCube = new THREE.CubeTextureLoader().load( urls );
				   var refractionCube = new THREE.CubeTextureLoader().load( urls );
			       refractionCube.mapping = THREE.SphericalReflectionMapping;
			       refractionCube.format = THREE.RGBFormat;

		  			// scene.background = refractionCube;


				 var iridescent = new THREE.ShaderMaterial( {

		          uniforms: { 
		            tMatCap: {type: 't', value: new_texture },
		          },
          
		          vertexShader: document.getElementById( 'sem-vs' ).textContent,
		          fragmentShader: document.getElementById( 'sem-fs' ).textContent,
		          flatShading: THREE.SmoothShading
		          
		        } );


					//new code

					var options = {
						generateMipmaps: true,
						minFilter: THREE.LinearMipmapLinearFilter,
						magFilter: THREE.LinearFilter
					};


					var textureLoader = new THREE.TextureLoader();

					var new_texture = textureLoader.load( 'examples/textures/IMG_9859.JPG' );
					new_texture.mapping = THREE.UVMapping;
					new_texture.repeat.set( 50 ,50);
					new_texture.wrapS = new_texture.wrapT = THREE.RepeatWrapping;
					new_texture.magFilter = THREE.LinearFilter;
					new_texture.anisotropy = renderer.getMaxAnisotropy();

			    var cylinderGeom = new THREE.CylinderGeometry(2, 1.5, 5, 50, 40, true);

				var vec3 = new THREE.Vector3(); // temp vector
				cylinderGeom.vertices.forEach(v => {
				  vec3.copy(v); // copy current vertex to the temp vector
				  vec3.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
				  vec3.normalize(); // normalize
				  if (2.2>v.y) {
				  vec3.multiplyScalar(Math.sin(v.y/3 * Math.PI-4) * 0.9)
				  }
				  else{
				  	 vec3.multiplyScalar(Math.sin(v.y/2 * Math.PI-5) * 0.9)
				  } 
				  // multiply with sin function
				  v.add(vec3); // add the temp vector to the current vertex
				})
				cylinderGeom.computeVertexNormals();

				cylinder = new THREE.Mesh(cylinderGeom, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#D98F89'
				}));
				scene.add(cylinder);
				cylinder.position.x = 0;            
			    cylinder.position.z = 200;
			    cylinder.position.y = 0;
			    cylinder.visible = false;
			    cylinder.scale.set(140,140,140);

			    

			    var cylinderGeom1 = new THREE.CylinderGeometry(0.5, 1, 5, 40, 70, true);

				var vec31 = new THREE.Vector3(); // temp vector
				cylinderGeom1.vertices.forEach(v => {
				  vec31.copy(v); // copy current vertex to the temp vector
				  vec31.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
				  vec31.normalize(); // normalize
				  vec31.multiplyScalar(Math.sin(v.y * Math.PI) * 0.2) // multiply with sin function
				  v.add(vec31); // add the temp vector to the current vertex
				})
				cylinderGeom1.computeVertexNormals();

				cylinder1 = new THREE.Mesh(cylinderGeom1, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#B35F40'
				}));
				scene.add(cylinder1);
				cylinder1.position.x = 0;            
			    cylinder1.position.z = 200;
			    cylinder1.position.y = 0;
			    cylinder1.visible = false;
			    cylinder1.scale.set(160,160,160);


			    var cylinderGeom2 = new THREE.CylinderGeometry(0.8, 1, 5, 40, 80, true);

				var vec32 = new THREE.Vector3(); // temp vector
				cylinderGeom2.vertices.forEach(v => {
				  vec32.copy(v); // copy current vertex to the temp vector
				  vec32.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
				  vec32.normalize(); // normalize
				  vec32.multiplyScalar(Math.cos(v.y/2 * Math.PI -6) * 0.4) // multiply with sin function
				  v.add(vec32); // add the temp vector to the current vertex
				})
				cylinderGeom2.computeVertexNormals();

				cylinder2 = new THREE.Mesh(cylinderGeom2, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#CF836B'
				}));
				scene.add(cylinder2);
				cylinder2.position.x = 0;            
			    cylinder2.position.z = 200;
			    cylinder2.position.y = 0;
			    cylinder2.visible = false;
			    cylinder2.scale.set(160,160,160);


			    //vase3

			 	var radiusTop = 0.5;
			 	var radiusBottom = 0.5;
			 	var height = 12;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -6;
			 	var legCurve = 0.3;
			 	var legWidth = 0.1;
			 	var legOffset = -3.6;

			 	// belly
			 	var bellyTop = 0;
			 	var bellyCurve = 1.6;
			 	var bellyWidth = 1;
			 	var bellyOffset = 4.15;

			 	//neck
			 	// var neckTop = 6;
			 	// var neckCurve = 7;
			 	// var neckWidth = 0.6;
			 	// var neckOffset = 1;

			 	var neckTop = 6;
			 	var neckCurve = 7;
			 	var neckWidth = 0.133;
			 	var neckOffset = 3;

			 	//mouth
			 	var mouthCurve = 1;
			 	var mouthWidth = 2;
			 	var mouthOffset = 4;

			    var cylinderGeom3 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom3.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	// tmp.copy(vertex);
						// vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						// vertex.add(tmp);
					  	vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom3.computeVertexNormals();

				cylinder3 = new THREE.Mesh(cylinderGeom3, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#D18462'
				}));
				scene.add(cylinder3);
				cylinder3.position.x = 0;            
			    cylinder3.position.z = 200;
			    cylinder3.position.y = 0;
			    cylinder3.visible = true;
			    cylinder3.scale.set(90,90,90);



			    var radiusTop = 0.9;
			 	var radiusBottom = 0.5;
			 	var height = 9;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -6;
			 	var legCurve = 0.3;
			 	var legWidth = 0.1;
			 	var legOffset = -3.6;

			 	// belly
			 	var bellyTop = 2.94;
			 	var bellyCurve = 2.3;
			 	var bellyWidth = 2;
			 	var bellyOffset = 2.29;

			 	//neck
			 	var neckTop = 6;
			 	var neckCurve = 0.59;
			 	var neckWidth = 0.39;
			 	var neckOffset = 4;

			 	//mouth
			 	var mouthCurve = 1;
			 	var mouthWidth = 2;
			 	var mouthOffset = 2;

			    var cylinderGeom4 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom4.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	// vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	// tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						// vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom4.computeVertexNormals();

				cylinder4 = new THREE.Mesh(cylinderGeom4, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#E6C4AE'
				}));
				scene.add(cylinder4);
				cylinder4.position.x = 0;            
			    cylinder4.position.z = 200;
			    cylinder4.position.y = 0;
			    cylinder4.visible = false;
			    cylinder4.scale.set(80,80,80);
			    


			 //    var radiusTop = 0.4;
			 // 	var radiusBottom = 2.2;
			 // 	var height = 12;
			 // 	var radialSegments = 80;
			 // 	var heightSegments = 90;
			 // 	var openEnded = true;

			 // 	// leg 
			 // 	var legTop = -6;
			 // 	var legCurve = 0.3;
			 // 	var legWidth = 0.2;
			 // 	var legOffset = -2.6;

			 // 	// belly
			 // 	var bellyTop = 3.6;
			 // 	var bellyCurve = 0.4;
			 // 	var bellyWidth = 0.2;
			 // 	var bellyOffset = 0.62;

			 // 	//neck
			 // 	var neckTop = 7;
			 // 	// var neckCurve = 0.712;
			 // 	var neckCurve = 0.72;
			 // 	var neckWidth = 0.6;
			 // 	var neckOffset = -1.85;

			 // 	//mouth
			 // 	var mouthCurve = 2;
			 // 	var mouthWidth = 2;
			 // 	var mouthOffset = 1;

			 //    var cylinderGeom5 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				// cylinderGeom5.vertices.forEach(v => {
				// 	var vertex = new THREE.Vector3(); // temp vector
				// 	vertex.copy(v); // copy current vertex to the temp vector
				// 	vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
				// 	vertex.normalize(); // normalize

				// 	//leg
				// 	if (v.y <= legTop) {
				// 		var tmp = new THREE.Vector3(); // temp vector
				// 		// tmp.copy(vertex);
				// 	  	vertex.multiplyScalar(legWidth); 
				// 	  	// vertex.add(tmp);
				// 	  	// vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
				// 	}

				// 	//belly
				// 	if (v.y <= bellyTop && v.y > legTop ) {
				// 		var tmp = new THREE.Vector3(); // temp vector
				// 		tmp.copy(vertex);
				// 	  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
				// 	  	vertex.add(tmp);
				// 	}

				// 	//neck
				// 	if (v.y <= neckTop && v.y > bellyTop ) {
				// 	  	var tmp = new THREE.Vector3(); // temp vector
				// 	  	tmp.copy(vertex);
				// 		vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
				// 		vertex.add(tmp);
				// 	  	// vertex.multiplyScalar(neckWidth);
				// 	}

				// 	//mouth
				// 	if (v.y > neckTop ) {
				// 		var tmp = new THREE.Vector3(); // temp vector
				// 		tmp.copy(vertex);
				// 	  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
				// 	  	vertex.add(tmp);
				// 	}

					   
				// 	v.add(vertex); // add the temp vector to the current vertex
				// })

				// cylinderGeom5.computeVertexNormals();

				// cylinder5 = new THREE.Mesh(cylinderGeom5, new THREE.MeshPhysicalMaterial({
				//   side: THREE.DoubleSide,
				//   color:'#D5B391'
				// }));
				// scene.add(cylinder5);
				// cylinder5.position.x = 0;            
			 //    cylinder5.position.z = 200;
			 //    cylinder5.position.y = 0;
			 //    cylinder5.visible = true;
			 //    cylinder5.scale.set(80,80,80);


			 	//Vase#5

			    var radiusTop = 0.4;
			 	var radiusBottom = 2.2;
			 	var height = 11;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -6;
			 	var legCurve = 0.4;
			 	var legWidth = 0.2;
			 	var legOffset = 1;

			 	// belly
			 	var bellyTop = 3.6;
			 	var bellyCurve = 0.4;
			 	var bellyWidth = 0.2;
			 	var bellyOffset = 0.62;

			 	//neck
			 	var neckTop = 7;
			 	// var neckCurve = 0.712;
			 	var neckCurve = 0.72;
			 	var neckWidth = 0.6;
			 	var neckOffset = -1.8;

			 	//mouth
			 	var mouthCurve = 2;
			 	var mouthWidth = 2;
			 	var mouthOffset = 0;


			    var cylinderGeom5 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom5.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom5.computeVertexNormals();

				cylinder5 = new THREE.Mesh(cylinderGeom5, new THREE.MeshPhysicalMaterial({
				  color:'#D5B391',
				  side: THREE.DoubleSide
				}));
				scene.add(cylinder5);
				cylinder5.position.x = 0;            
			    cylinder5.position.z = 200;
			    cylinder5.position.y = 0;
			    cylinder5.visible = false;
			    cylinder5.scale.set(80,80,80);


			    //Vase#6

			    var radiusTop = 0.9;
			 	var radiusBottom = 0.5;
			 	var height = 12;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -5.4;
			 	var legCurve = 0.5;
			 	var legWidth = 0;
			 	var legOffset = -4.8;

			 	// var legTop = -5.3;
			 	// var legCurve = 2.5;
			 	// var legWidth = 1.3;
			 	// var legOffset = -6.8;

			 	// belly
			 	var bellyTop = 2.94;
			 	var bellyCurve = 2.3;
			 	var bellyWidth = 2;
			 	var bellyOffset = 2.29;

			 	//neck
			 	var neckTop = 6;
			 	var neckCurve = 0.59;
			 	var neckWidth = 0.39;
			 	var neckOffset = 4;

			 	//mouth
			 	var mouthCurve = 1;
			 	var mouthWidth = 2;
			 	var mouthOffset = 2;

			    var cylinderGeom6 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom6.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	// tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						// vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom6.computeVertexNormals();

				cylinder6 = new THREE.Mesh(cylinderGeom6, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#B35F40'
				}));
				scene.add(cylinder6);
				cylinder6.position.x = 0;            
			    cylinder6.position.z = 200;
			    cylinder6.position.y = 0;
			    cylinder6.visible = false;
			    cylinder6.scale.set(80,80,80);

			  	
			  	//Vase#7


			 	var radiusTop = 0.6;
			 	var radiusBottom = 0.4;
			 	var height = 10;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -6;
			 	var legCurve = 0.3;
			 	var legWidth = 0.1;
			 	var legOffset = -3.6;

			 	// belly
			 	var bellyTop = 10;
			 	var bellyCurve = 3;
			 	var bellyWidth = 1.7;
			 	var bellyOffset = 2;

			 	//neck
			 	var neckTop = 4.8;
			 	var neckCurve = 1.5;
			 	var neckWidth = 1;
			 	var neckOffset = 3;

			 	//mouth
			 	var mouthCurve = 1;
			 	var mouthWidth = 0;
			 	var mouthOffset = 4.6;

			    var cylinderGeom7 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom7.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom7.computeVertexNormals();

				cylinder7 = new THREE.Mesh(cylinderGeom7, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#E6C4AE'
				}));
				scene.add(cylinder7);
				cylinder7.position.x = 0;            
			    cylinder7.position.z = 200;
			    cylinder7.position.y = 0;
			    cylinder7.visible = false;
			    cylinder7.scale.set(80,80,80);


			    // Vase#8

			    var radiusTop = 0.4;
			 	var radiusBottom = 0.7;
			 	var height = 13;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -7;
			 	var legCurve = 0.3;
			 	var legWidth = 0.1;
			 	var legOffset = -3.8;

			 	// belly
			 	var bellyTop = 3.4;
			 	var bellyCurve = 3;
			 	var bellyWidth = 1.8;
			 	var bellyOffset = 2;

			 	//neck
			 	var neckTop = 7;
			 	var neckCurve = 0.68;
			 	var neckWidth = 0.4;
			 	var neckOffset = 4.41;

			 	//mouth
			 	var mouthCurve = 1;
			 	var mouthWidth = 2;
			 	var mouthOffset = 2;

			    var cylinderGeom8 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom8.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom8.computeVertexNormals();


				    console.log('radiusTopslider'+ radiusTop);
		        	console.log('radiusBottom'+radiusBottom);
		        	console.log('height'+height);
		        	console.log('legTop'+legTop); 
		        	console.log('legCurve'+legCurve); 
		        	console.log('legWidth'+legWidth);
		        	console.log('legOffset'+legOffset);
		        	console.log('bellyTop'+bellyTop);
		        	console.log('bellyCurve'+bellyCurve);
		        	console.log('bellyWidth'+bellyWidth);
		        	console.log('bellyOffset'+bellyOffset);
		        	console.log('neckTop'+neckTop);
		        	console.log('neckCurve'+neckCurve);
		        	console.log('neckWidth'+neckWidth);
		        	console.log('neckOffset'+neckOffset);
		        	console.log('mouthCurve'+mouthCurve);
		        	console.log('mouthWidth'+mouthWidth);
		        	console.log('mouthOffset'+mouthOffset);  	

				cylinder8 = new THREE.Mesh(cylinderGeom8, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#D98F89'
				}));
				scene.add(cylinder8);
				cylinder8.position.x = 0;            
			    cylinder8.position.z = 200;
			    cylinder8.position.y = 0;
			    cylinder8.visible = false;
			    cylinder8.scale.set(80,80,80);


			      //Vase#9

			    var radiusTop = 0.3;
			 	var radiusBottom = 2;
			 	var height = 14;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -7.2;
			 	var legCurve = 2;
			 	var legWidth = 1;
			 	var legOffset = -2.6;

			 	//belly
				var bellyTop = 3.57;
			 	var bellyCurve = 3;
			 	var bellyWidth = 1.7;
			 	var bellyOffset = 2;

			 	//neck
			 	var neckTop = 6.7;
			 	var neckCurve = 0.93;
			 	var neckWidth = 0.3;
			 	var neckOffset = 5.8;


			 	//mouth
			 	var mouthCurve = 2;
			 	var mouthWidth = 1.4;
			 	var mouthOffset = 1.2;

			    var cylinderGeom9 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom9.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	// vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	tmp.copy(vertex);
						// vertex.multiplyScalar(Math.abs(Math.sin(v.y/neckCurve+neckOffset) * neckWidth)) 
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth)
						vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						// tmp.copy(vertex);
						vertex.multiplyScalar(mouthWidth);
					  	// vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	// vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom9.computeVertexNormals();

				cylinder9 = new THREE.Mesh(cylinderGeom9, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#D18462'
				}));
				scene.add(cylinder9);
				cylinder9.position.x = 0;            
			    cylinder9.position.z = 200;
			    cylinder9.position.y = 0;
			    // cylinder9.visible = false;
			    cylinder9.scale.set(70,70,70);

			    function CustomSinCurve( scale ) {
					THREE.Curve.call( this );
					this.scale = ( scale === undefined ) ? 1 : scale;
				}

				CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
				CustomSinCurve.prototype.constructor = CustomSinCurve;

				CustomSinCurve.prototype.getPoint = function ( t ) {

					var tx = t * 4 - 1.8;
					var ty = Math.sin(4.3*t-0.5)*1.4;
					var tz = 0;
					return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

				};

			    var path = new CustomSinCurve( 10 );
				var geometry = new THREE.TubeBufferGeometry( path, 80, 2, 14, false );
				var material = new THREE.MeshPhysicalMaterial( { color: '#D18462' } );
				var mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				mesh.position.x = 125;            
			    mesh.position.z = 190;
			    mesh.position.y = 155;
			    mesh.rotation.z = Math.PI/-5;
			    // mesh.visible = א; 
			    mesh.scale.set(10,10,10);


			    function CustomSinCurve( scale ) {
					THREE.Curve.call( this );
					this.scale = ( scale === undefined ) ? 1 : scale;
				}

				CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
				CustomSinCurve.prototype.constructor = CustomSinCurve;

				CustomSinCurve.prototype.getPoint = function ( t ) {

					var tx = t * 4 - 1.8;
					var ty = Math.sin(4.3*t-0.5)*1.4;
					var tz = 0;
					return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

				};

			    var path = new CustomSinCurve( 10 );
				var geometry = new THREE.TubeBufferGeometry( path, 80, 2, 14, false );
				var material = new THREE.MeshPhysicalMaterial( { color: '#D18462' } );
				var mesh1 = new THREE.Mesh( geometry, material );
				scene.add( mesh1 );
				mesh1.position.x = -125;            
			    mesh1.position.z = 190;
			    mesh1.position.y = 155;
			    mesh1.rotation.z = Math.PI/-5;
			    mesh1.rotation.y = 375* Math.PI/360;
			    // mesh1.visible = false;
			    mesh1.scale.set(10,10,10);

			    group = new THREE.Group();
				group.add( mesh1 );
				group.add( mesh );
				group.add( cylinder9 );
				group.visible = false;
				scene.add( group );

			   
			    // Vase#10

			    var radiusTop = 1;
			 	var radiusBottom = 2.5;
			 	var height = 18;
			 	var radialSegments = 80;
			 	var heightSegments = 90;
			 	var openEnded = true;

			 	// leg 
			 	var legTop = -9.5;
			 	var legCurve = 0.3;
			 	var legWidth = 0.1;
			 	var legOffset = -3.8;

			 	// belly
			 	var bellyTop = 5.59;
			 	var bellyCurve = 4;
			 	var bellyWidth = 2.6;
			 	var bellyOffset = 1.98;

			 	//neck
			 	var neckTop = 9;
			 	var neckCurve = 3;
			 	var neckWidth = 0.6;
			 	var neckOffset = 2.5;

			 	//mouth
			 	var mouthCurve = 1;
			 	var mouthWidth = 2;
			 	var mouthOffset = 2;

			    var cylinderGeom10 = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
				cylinderGeom10.vertices.forEach(v => {
					var vertex = new THREE.Vector3(); // temp vector
					vertex.copy(v); // copy current vertex to the temp vector
					vertex.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
					vertex.normalize(); // normalize

					//leg
					if (v.y <= legTop) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/legCurve+legOffset) * legWidth); 
					  	// vertex.multiplyScalar(legWidth); 
					  	vertex.add(tmp);
					  	
					}

					//belly
					if (v.y <= bellyTop && v.y > legTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/bellyCurve+bellyOffset) * bellyWidth); 
					  	vertex.add(tmp);
					}

					//neck
					if (v.y <= neckTop && v.y > bellyTop ) {
					  	var tmp = new THREE.Vector3(); // temp vector
					  	tmp.copy(vertex);
						vertex.multiplyScalar(Math.sin(v.y/neckCurve+neckOffset) * neckWidth) 
						vertex.add(tmp);
					  	// vertex.multiplyScalar(neckWidth);
					}

					//mouth
					if (v.y > neckTop ) {
						var tmp = new THREE.Vector3(); // temp vector
						tmp.copy(vertex);
					  	vertex.multiplyScalar(Math.sin(v.y/mouthCurve+mouthOffset) * mouthWidth); 
					  	vertex.add(tmp);
					}

					   
					v.add(vertex); // add the temp vector to the current vertex
				})

				cylinderGeom10.computeVertexNormals();

				cylinder10 = new THREE.Mesh(cylinderGeom10, new THREE.MeshPhysicalMaterial({
				  side: THREE.DoubleSide,
				  color:'#D98F89'
				}));
				scene.add(cylinder10);
				cylinder10.position.x = 0;            
			    cylinder10.position.z = 200;
			    cylinder10.position.y = 0;
			    cylinder10.visible = false;
			    cylinder10.scale.set(50,50,50);


			 //    var cylinderGeom11 = new THREE.CylinderGeometry(0.5, 1, 5, 40, 70, true);

				// var vec311 = new THREE.Vector3(); // temp vector
				// cylinderGeom1.vertices.forEach(v => {
				//   vec311.copy(v); // copy current vertex to the temp vector
				//   vec311.setY(0); // leave x and z (thus the vector is parallel to XZ plane)
				//   vec311.normalize(); // normalize
				//   vec311.multiplyScalar(Math.sin(v.y * Math.PI) * 0.2) // multiply with sin function
				//   v.add(vec311); // add the temp vector to the current vertex
				// })
				// cylinderGeom11.computeVertexNormals();

				// var cylinder11 = new THREE.Mesh(cylinderGeom11, new THREE.MeshPhysicalMaterial({
				//   side: THREE.DoubleSide,
				//   color:'#B35F40'
				// }));
				// scene.add(cylinder11);
				// cylinder11.position.x = 0;            
			 //    cylinder11.position.z = 200;
			 //    cylinder11.position.y = 0;
			 //    cylinder11.visible = true;
			 //    cylinder11.scale.set(160,160,160);

			 // 	twisted_geometry = new THREE.CylinderGeometry(105, 105, 700, 30, 0, true ); 
				// var material = new THREE.MeshPhysicalMaterial({color:'#B35F40',
				// side: THREE.DoubleSide }); 
				// cube = new THREE.Mesh(twisted_geometry, material); 
				// scene.add(cube);

				// for (var i = 0; i<80 ; i++) {
				// 	twist(twisted_geometry);	
				// }
				
			    // group.add(cylinder3);
			    // group.add(cylinder2);
			    // group.add(cylinder1);
			    // group.add(cylinder);

			    list = [ cylinder3, cylinder2, cylinder1, cylinder, cylinder8, cylinder4, group, cylinder5, cylinder7, cylinder6, cylinder10];
			   	colorlist = ['#8F6235','#D7B9B0','#D2B29C','#D9D2D5','#FFD6C4','#B39181', '#D7B9B0','#D9D2D5','#8F6235','#D2B29C'];

}
		
		function animate(){
	
		// cylinder.position.y = Math.sin(y1)*20+50;
		// cone.rotation.z += 0.02;

		y1 += 0.03;
		x1 += 0.01;
  		z1 += 0.01;

		// sphere.position.x = (-Math.cos(x1)*580)+80, -80;
		// sphere.position.z = (-Math.sin(z1)*480+170);
		
		requestAnimationFrame(animate);
		render();
	}
		

		function twist(geometry) {
				  var quaternion = new THREE.Quaternion();

				  for (let i = 0; i < geometry.vertices.length; i++) {
				    // a single vertex Y position
				    var yPos = geometry.vertices[i].y;
				    var twistAmount = 10;
				    var upVec = new THREE.Vector3(0, 1, 0);

				    quaternion.setFromAxisAngle(
				      upVec, 
				      (Math.PI / 180) * (yPos / twistAmount)
				    );

				    geometry.vertices[i].applyQuaternion(quaternion);
				  }
				  
				  // tells Three.js to re-render this mesh
				  geometry.verticesNeedUpdate = true;
				}
		

		function onDocumentMouseClick( event ) {

			var i;

			for (i = 0; i < list.length; i++){

				list[i].visible = false;  
			}

			var number = getRandomInt(0,list.length);
			counter += 1;
			list[counter%list.length].visible = true;
			renderer.setClearColor(colorlist[counter%list.length]);
			

		}

		function getRandomInt(min, max) {
		  min = Math.ceil(min);
		  max = Math.floor(max);
		  return Math.floor(Math.random() * (max - min) + min); 
		}

		function onDocumentMouseMove(event) {

        mouseX = ( event.clientX - windowHalfX );
        mouseY = ( event.clientY - windowHalfY );

      }


      function onDocumentWheel(event) {
        event.preventDefault();
        //mag = event.deltaY * 0.0008;
      }

       window.onresize = function(event) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      };  

	
	function render(){

		camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y = THREE.Math.clamp( camera.position.y + ( - ( mouseY - 600 ) - camera.position.y ) * .05, 50, 1000 );

        dirLight.position.x += ( mouseX - dirLight.position.x - 1000 ) * .05;
        // group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
        camera.lookAt( scene.position );
		renderer.render( scene, camera );
	}


		

		</script>
	</body>
</html>
