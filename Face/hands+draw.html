<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.2.0/p5.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/3.6.3/firebase.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- The main handpose library -->
  <script src="https://unpkg.com/@tensorflow-models/handpose@0.0.7/dist/handpose.js"></script>

  <script src="fingerpose.js" type="text/javascript"></script>
  <meta charset="utf-8" />

</head>
  <body>
    <a id="gallery" href="gallery.html">Info</a>
    <span id="on_start">
      Use your üëÜ to draw, use üñê to stop drawing.
    </span>
    <!-- <span class="date"></span> -->
    <span class="name">Back <br>to</br> Kindergarten</span>
    <video class="input_video"></video>
    
    <div id="canvascontainer"></div>

    <ul class="actions">
    <li class="buttons_list grid-item"> 
    <button id="uploadButton">Upload</button>
    </li>
    <li class="buttons_list grid-item">
    <button id="downloadButton">Download</button>
    </li>
    <li class="buttons_list grid-item">
    <button id="clearButton">New</button>
    </li>
    <!-- <li class="buttons_list">
    <button id="btn">Color</button>
    </li> -->
    </ul>

    <ul class="colors">
    <li class="colors_list">
      <button id="btn"></button>
    </li>
    <li class="colors_list">
      <button id="btn_01"></button>
    </li>
    <li class="colors_list">
      <button id="btn_02"></button>
    </li>
    <li class="colors_list">
      <button id="btn_03"></button>
    </li>
    <li class="colors_list">
      <button id="btn_04"></button>
    </li>
    <li class="colors_list">
      <button id="btn_05"></button>
    </li>
    <li class="colors_list">
      <button id="btn_06"></button>
    </li>
    <li class="colors_list">
      <button id="btn_07"></button>
    </li>
    </ul>

    <div class="modal">
      <div class="save-overlay">    
          <div class="content-overlay">
            <p class="text">
              Share your drawing 
            </p>
            <div id="preview"> 
            </div>
            <div class="form">
              <input type="text" id="name_input" name="fname">
              <button id="Submit">Submit</button>
           </div>   
          </div>
        <a href='#' class="save-overlay__close">
           x <!-- &times; --></a>
        </div>
    </div>

    <div id="frame">
      <p class="desktop_view">For the full experince please open this website in the desktop</p>
    </div>

  </body>
</html>

<style type="text/css">
 html, body {
    margin: 0;
    padding: 0;
  }
  
  @font-face {
  font-family: CommonSans-Regular;
  src: url(CommonSans-Regular 2.otf);
}

.save-overlay {
  -webkit-transition: -webkit-transform .35s cubic-bezier(.44,0,.35,1.28), bottom .35s cubic-bezier(.44,0,.35,1.28);
  transition: transform .35s cubic-bezier(.44,0,.35,1.28), bottom .35s cubic-bezier(.44,0,.35,1.28);
  font-family: CommonSans-Regular;
  background: white;
  border: 1px solid #382826;
  border-radius: 8px;
  width: calc(100% - 70%);
  /*height: calc(100% - 88%);*/
  position: fixed;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  z-index: 4000;
  display: none;
  padding: 20px;
}

.modal{
  background-color: rgb(0, 0, 0, 0.1);
  height: 100%;
  width: 100%;
  z-index: 3000;
  top: 50%;
  left: 50%;
  -webkit-transform: translate(-50%, -50%);
  transform: translate(-50%, -50%);
  display: none;
  position: fixed;
}

.content-overlay{
  width: 100%;
  display: none;
  text-align:center;
}

.active_overlay{
  display: block;
}
.save-overlay.open {
  -webkit-transform: translate(-50%, 50%);
  transform: translate(-50%, 50%);
  bottom: 53vh;
  z-index: 4000;
}

.save-overlay__close {
  font-size: 17px;
  font-family: CommonSans-Regular;
  position: absolute;
  right: 20px;
  top: 15px;
  /*top: 1.2rem;*/
  color: black;
  cursor: pointer;
  text-decoration: none;
  z-index: 4000;
  /*right: calc(100% - 93%);*/
}


#gallery{
  font-size: 17px;
  font-family: CommonSans-Regular;
  color: black;
  text-decoration: none;
  padding: 46px;
  margin-left: 200px;
  position: fixed;

}


.actions{
    display: flex;
    align-items: center;
    justify-content: center;
    width: 50%;
    padding: 0;
    position: fixed;
    bottom: 0;
    right: 50%;
    margin: 0 auto;
    transform: translate(50%, 0);
}

.buttons_list{
  display: block;
  flex: 0 1 auto; /* Default */
  list-style-type: none;
  margin-bottom: 10px;
}

#on_start{
  font-size: 17px;
  font-family: CommonSans-Regular;
  position: absolute;
  width: 50%;
  top: 50%;
  transform: translate(50%, 50%);
  text-align: center
}

.colors{
    display: flex;
    align-items: center; /* Default */
    justify-content: center;
    /*width: 20s%;*/
    margin-bottom: 60px;
    padding-top: 0;
    padding-bottom: 0;
    padding-left: 4px;
    padding-right: 4px;
    position: fixed;
    bottom: 0;
    right: 50%;
    border: 1px solid #000;
    border-radius: 8px;
    transform: translate(50%, 0);
}

.colors_list{
  display: block;
  flex: 0 1 auto; /* Default */
  list-style-type: none;
  margin: 6px;

}

#btn{
  padding: 14px;
  border: none;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  /*border: 1px solid #000;*/
  background-color: white;
  background-color: #F26945;
}

#btn_01{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color: #FAE80B;
}

#btn_02{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color:#CF2133;
}

#btn_03{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color:#0E8142;
}

#btn_04{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color:#4D3292;
}

#btn_05{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color:#2D63AF;
}

#btn_06{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color:#81592F;
}

#btn_07{
  padding: 14px;
  cursor: pointer;
  /*margin: 10px;*/
  border-radius: 8px;
  border: none;
  background-color:#000000;
}

#uploadButton{
  /*padding: 10px;*/
  padding: 10px 26px 10px 26px;
  border: 1px solid #000;
  border-radius: 8px;
  font-size: 15px;
  font-family: CommonSans-Regular;
  background-color: white;
  cursor: pointer;
}

#uploadButton:hover{
  background-color: #eee;
}

#downloadButton{
  padding: 10px 26px 10px 26px;
  margin: 0 10px 0px;
  border: 1px solid #000;
  background-color: white;
  border-radius: 8px;
  font-size: 15px;
  font-family: CommonSans-Regular;
  cursor: pointer;
}

#downloadButton:hover{
 background-color: #eee;
}
#Submit{
  border: 1px solid #000;
  border-radius: 8px;
  font-size: 15px;
  font-family: CommonSans-Regular;
  padding: 1px 10px;
  flex-grow: 1;
  max-width: 150px;
  position: relative;
  background-color: white;
  cursor: pointer;
}

#Submit:hover{
  background-color: #eee;
}

input{
  height: 38px;
  position: relative;
  border-radius: 4px;
  min-width: 30px;
  padding: 1px 5px;
  background-color: white;
  border: 1.4px solid #000;
  flex-grow: 1;
  fill: black;
}

:focus {
  outline: none;

}

.form{
  display: flex;
  column-gap: 10px;
  position: relative;
  /*transform: translate(0%, 170%);*/
}

#preview{
  width: calc(100% - 1%);
  height: 270px;
  margin-right: 0;
  border: 1px solid #000;
  margin-top: 30px;
  margin-bottom: 20px;
  /*align-items: center;*/
  vertical-align: middle;
}

.text{
  font-size: 17px;
  font-family: CommonSans-Regular;
  position: absolute;
  left: 20px;
  top: 0;
}

#clearButton{
  padding: 10px 26px 10px 26px;
  border: 1px solid #000;
  border-radius: 8px;
  font-size: 15px;
  font-family: CommonSans-Regular;
  background-color: white;
  cursor: pointer;
}

#clearButton:hover{
  background-color: #eee;
}

.name{
  padding: 5px;
  margin: 0;
  font-size: 17px;
  position: fixed;
  font-family: CommonSans-Regular;
}


.name_input{
  font-size: 17px;
  font-family: CommonSans-Regular;
}

.date{
  padding: 46px;
  margin-left: 120px;
  font-size: 17px;
  position: fixed;
  font-family: CommonSans-Regular;
}

  canvas {
    display: block;
  }
  
  video{
    position: fixed;
    right: 0;
    display: none;
    -webkit-filter: grayscale(100%); 
    filter: grayscale(100%);
  }

  #frame{
    display: none;
  }
  @media only screen and (max-width: 980px){

  .actions{
      display: none;
    }

  .name{
      display: none;
    }

  #canvascontainer{
      display: none;
    }
   #gallery{
     display: none;
   } 

   #frame {
    display: block;
    width: 100vw;
    height: 100vh;
    position: fixed;
    inset: 0px;
    z-index: 999;
    background: rgb(255, 255, 255);
} 

.desktop_view {
    font-size: 25px;
    display: flex;
    flex-direction: column;
    text-align: center;
    place-content: center;
    width: 100vw;
    height: 100vh;
    margin: 0px;
    padding: 0px;
    font-family: CommonSans-Regular;
 }   
   #on_start{
    display: none;
    } 

}
</style>

<script type="text/javascript">

class FingerPoseEstimator {

  constructor(options) {

    this.options = {...{

      // curl estimation
      HALF_CURL_START_LIMIT: 60.0,
      NO_CURL_START_LIMIT: 130.0,

      // direction estimation
      DISTANCE_VOTE_POWER: 1.1,
      SINGLE_ANGLE_VOTE_POWER: 0.9,
      TOTAL_ANGLE_VOTE_POWER: 1.6
    }, ...options};
  }

  estimate(landmarks) {

    // step 1: calculate slopes

    let slopesXY = [];
    let slopesYZ = [];

    for(let finger of fp.Finger.all) {

      let points = fp.Finger.getPoints(finger);
      let slopeAtXY = [];
      let slopeAtYZ = [];

      for(let point of points) {

        let point1 = landmarks[point[0]];
        let point2 = landmarks[point[1]];

        // calculate single slope
        let slopes = this.getSlopes(point1, point2);
        let slopeXY = slopes[0];
        let slopeYZ = slopes[1];
        slopeAtXY.push(slopeXY);
        slopeAtYZ.push(slopeYZ);
      }

      slopesXY.push(slopeAtXY);
      slopesYZ.push(slopeAtYZ);
    }

    // step 2: calculate orientations

    let fingerCurls = [];
    let fingerDirections = [];

    for(let finger of fp.Finger.all) {

      // start finger predictions from palm - except for thumb
      let pointIndexAt = (finger == fp.Finger.Thumb) ? 1 : 0;

      let fingerPointsAt = fp.Finger.getPoints(finger);
      let startPoint = landmarks[fingerPointsAt[pointIndexAt][0]];
      let midPoint = landmarks[fingerPointsAt[pointIndexAt + 1][1]];
      let endPoint = landmarks[fingerPointsAt[3][1]];

      // check if finger is curled
      let fingerCurled = this.estimateFingerCurl(
        startPoint, midPoint, endPoint
      );

      let fingerPosition = this.calculateFingerDirection(
        startPoint, midPoint, endPoint,
        slopesXY[finger].slice(pointIndexAt)
      );

      fingerCurls[finger] = fingerCurled;
      fingerDirections[finger] = fingerPosition;
    }

    return { curls: fingerCurls, directions: fingerDirections }
  }

  // point1, point2 are 2d or 3d point arrays (xy[z])
  // returns either a single scalar (2d) or array of two slopes (3d)
  getSlopes(point1, point2) {

    let slopeXY = this.calculateSlope(point1[0], point1[1], point2[0], point2[1]);
    if(point1.length == 2) {
      return slopeXY;
    }

    let slopeYZ = this.calculateSlope(point1[1], point1[2], point2[1], point2[2])
    return [slopeXY, slopeYZ];
  }

  angleOrientationAt(angle, weightageAt = 1.0) {

    let isVertical = 0;
    let isDiagonal = 0;
    let isHorizontal = 0;

    if(angle >= 75.0 && angle <= 105.0) {
      isVertical = 1 * weightageAt;
    }
    else if(angle >= 25.0 && angle <= 155.0) {
      isDiagonal = 1 * weightageAt;
    }
    else {
      isHorizontal = 1 * weightageAt;
    }

    return [isVertical, isDiagonal, isHorizontal];
  }

  estimateFingerCurl(startPoint, midPoint, endPoint) {

    let start_mid_x_dist = startPoint[0] - midPoint[0];
    let start_end_x_dist = startPoint[0] - endPoint[0];
    let mid_end_x_dist = midPoint[0] - endPoint[0];
    
    let start_mid_y_dist = startPoint[1] - midPoint[1];
    let start_end_y_dist = startPoint[1] - endPoint[1];
    let mid_end_y_dist = midPoint[1] - endPoint[1];
  
    let start_mid_z_dist = startPoint[2] - midPoint[2];
    let start_end_z_dist = startPoint[2] - endPoint[2];
    let mid_end_z_dist = midPoint[2] - endPoint[2];
    
    let start_mid_dist = Math.sqrt(
      start_mid_x_dist * start_mid_x_dist +
      start_mid_y_dist * start_mid_y_dist +
      start_mid_z_dist * start_mid_z_dist
    );
    let start_end_dist = Math.sqrt(
      start_end_x_dist * start_end_x_dist +
      start_end_y_dist * start_end_y_dist +
      start_end_z_dist * start_end_z_dist
    );
    let mid_end_dist = Math.sqrt(
      mid_end_x_dist * mid_end_x_dist +
      mid_end_y_dist * mid_end_y_dist +
      mid_end_z_dist * mid_end_z_dist
    );

    let cos_in = (
      mid_end_dist * mid_end_dist +
      start_mid_dist * start_mid_dist -
      start_end_dist *start_end_dist
    ) / (2 * mid_end_dist * start_mid_dist);

    if(cos_in > 1.0) {
      cos_in = 1.0;
    }
    else if(cos_in < -1.0) {
      cos_in = -1.0;
    }

    let angleOfCurve = Math.acos(cos_in);

    angleOfCurve = (57.2958 * angleOfCurve) % 180;

    let fingerCurl;
    if(angleOfCurve > this.options.NO_CURL_START_LIMIT) {
      fingerCurl = fp.FingerCurl.NoCurl;
    }
    else if(angleOfCurve > this.options.HALF_CURL_START_LIMIT) {
      fingerCurl = fp.FingerCurl.HalfCurl;
    }
    else {
      fingerCurl = fp.FingerCurl.FullCurl;
    }


    return fingerCurl;
  }

  estimateHorizontalDirection(start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x) {

    let estimatedDirection;
    if(max_dist_x == Math.abs(start_end_x_dist)) {
      if(start_end_x_dist > 0) {
        estimatedDirection = fp.FingerDirection.HorizontalLeft;
      } else {
        estimatedDirection = fp.FingerDirection.HorizontalRight;
      }
    }
    else if(max_dist_x == Math.abs(start_mid_x_dist)) {
      if(start_mid_x_dist > 0) {
        estimatedDirection = fp.FingerDirection.HorizontalLeft;
      } else {
        estimatedDirection = fp.FingerDirection.HorizontalRight;
      }
    }
    else {
      if(mid_end_x_dist > 0) {
        estimatedDirection = fp.FingerDirection.HorizontalLeft;
      } else {
        estimatedDirection = fp.FingerDirection.HorizontalRight;
      }
    }

    return estimatedDirection;
  }

  estimateVerticalDirection(start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y) {

    let estimatedDirection;
    if(max_dist_y == Math.abs(start_end_y_dist)) {
      if(start_end_y_dist < 0) {
        estimatedDirection = fp.FingerDirection.VerticalDown;
      } else {
        estimatedDirection = fp.FingerDirection.VerticalUp;
      }
    }
    else if(max_dist_y == Math.abs(start_mid_y_dist)) {
      if(start_mid_y_dist < 0) {
        estimatedDirection = fp.FingerDirection.VerticalDown;
      } else {
        estimatedDirection = fp.FingerDirection.VerticalUp;
      }
    }
    else {
      if(mid_end_y_dist < 0) {
        estimatedDirection = fp.FingerDirection.VerticalDown;
      } else {
        estimatedDirection = fp.FingerDirection.VerticalUp;
      }
    }

    return estimatedDirection;
  }

  estimateDiagonalDirection(
    start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y,
    start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x
  ) {

    let estimatedDirection;
    let reqd_vertical_direction = this.estimateVerticalDirection(
      start_end_y_dist, start_mid_y_dist, mid_end_y_dist, max_dist_y
    );
    let reqd_horizontal_direction = this.estimateHorizontalDirection(
      start_end_x_dist, start_mid_x_dist, mid_end_x_dist, max_dist_x
    );
    
    if(reqd_vertical_direction == fp.FingerDirection.VerticalUp) {
      if(reqd_horizontal_direction == fp.FingerDirection.HorizontalLeft) {
        estimatedDirection = fp.FingerDirection.DiagonalUpLeft;
      } else {
        estimatedDirection = fp.FingerDirection.DiagonalUpRight;
      }
    }
    else {
      if(reqd_horizontal_direction == fp.FingerDirection.HorizontalLeft) {
        estimatedDirection = fp.FingerDirection.DiagonalDownLeft;
      } else {
        estimatedDirection = fp.FingerDirection.DiagonalDownRight;
      }
    }

    return estimatedDirection;
  }

  calculateFingerDirection(startPoint, midPoint, endPoint, fingerSlopes) {

    let start_mid_x_dist = startPoint[0] - midPoint[0];
    let start_end_x_dist = startPoint[0] - endPoint[0];
    let mid_end_x_dist = midPoint[0] - endPoint[0];
    
    let start_mid_y_dist = startPoint[1] - midPoint[1];
    let start_end_y_dist = startPoint[1] - endPoint[1];
    let mid_end_y_dist = midPoint[1] - endPoint[1];

    let max_dist_x = Math.max(
      Math.abs(start_mid_x_dist),
      Math.abs(start_end_x_dist),
      Math.abs(mid_end_x_dist)
    );
    let max_dist_y = Math.max(
      Math.abs(start_mid_y_dist),
      Math.abs(start_end_y_dist),
      Math.abs(mid_end_y_dist)
    );

    let voteVertical = 0.0;
    let voteDiagonal = 0.0;
    let voteHorizontal = 0.0;

    let start_end_x_y_dist_ratio = max_dist_y / (max_dist_x + 0.00001);
    if(start_end_x_y_dist_ratio > 1.5) {
      voteVertical += this.options.DISTANCE_VOTE_POWER;
    }
    else if(start_end_x_y_dist_ratio > 0.66) {
      voteDiagonal += this.options.DISTANCE_VOTE_POWER;
    }
    else {
      voteHorizontal += this.options.DISTANCE_VOTE_POWER;
    }

    let start_mid_dist = Math.sqrt(
      start_mid_x_dist * start_mid_x_dist + start_mid_y_dist *start_mid_y_dist
    );
    let start_end_dist = Math.sqrt(
      start_end_x_dist * start_end_x_dist + start_end_y_dist * start_end_y_dist
    );
    let mid_end_dist = Math.sqrt(
      mid_end_x_dist * mid_end_x_dist + mid_end_y_dist * mid_end_y_dist
    );

    let max_dist = Math.max(start_mid_dist, start_end_dist, mid_end_dist);
    let calc_start_point_x = startPoint[0],
        calc_start_point_y = startPoint[1];
    let calc_end_point_x = endPoint[0],
        calc_end_point_y = endPoint[1];

    if(max_dist == start_mid_dist) {
      calc_end_point_x = endPoint[0],
      calc_end_point_y = endPoint[1];
    }
    else if(max_dist == mid_end_dist) {
      calc_start_point_x = midPoint[0],
      calc_start_point_y = midPoint[1];
    }

    let calcStartPoint = [calc_start_point_x, calc_start_point_y];
    let calcEndPoint = [calc_end_point_x, calc_end_point_y];

    let totalAngle = this.getSlopes(calcStartPoint, calcEndPoint);
    let votes = this.angleOrientationAt(totalAngle, this.options.TOTAL_ANGLE_VOTE_POWER);
    voteVertical += votes[0];
    voteDiagonal += votes[1];
    voteHorizontal += votes[2];

    for(let fingerSlope of fingerSlopes) {
      let votes = this.angleOrientationAt(fingerSlope, this.options.SINGLE_ANGLE_VOTE_POWER);
      voteVertical += votes[0];
      voteDiagonal += votes[1];
      voteHorizontal += votes[2];
    }

    // in case of tie, highest preference goes to Vertical,
    // followed by horizontal and then diagonal
    let estimatedDirection;
    if(voteVertical == Math.max(voteVertical, voteDiagonal, voteHorizontal)) {
      estimatedDirection = this.estimateVerticalDirection(
        start_end_y_dist,
        start_mid_y_dist, 
        mid_end_y_dist, max_dist_y
      );
    }
    else if(voteHorizontal == Math.max(voteDiagonal, voteHorizontal)) {
      estimatedDirection = this.estimateHorizontalDirection(
        start_end_x_dist,
        start_mid_x_dist,
        mid_end_x_dist, max_dist_x
      );
    }
    else {
      estimatedDirection = this.estimateDiagonalDirection(
        start_end_y_dist, start_mid_y_dist,
        mid_end_y_dist, max_dist_y,
        start_end_x_dist, start_mid_x_dist,
        mid_end_x_dist, max_dist_x
      );
    }

    return estimatedDirection;
  }

  calculateSlope(point1x, point1y, point2x, point2y) {

    let value = (point1y - point2y) / (point1x - point2x);
    let slope = Math.atan(value) * 180 / Math.PI;

    if(slope <= 0) {
      slope = -slope;
    }
    else if(slope > 0) {
      slope = 180 - slope;
    }

    return slope;
  }
}


  var is_raised_fist = false;
  var is_open_hand = false;
  var is_finger_up = false;
  var is_draw = true;

  const raisedDescription = new fp.GestureDescription('raised_fist');

  // thumb:
  raisedDescription.addCurl(fp.Finger.Thumb, fp.FingerCurl.HalfCurl, 1.0);

  // index:
  raisedDescription.addCurl(fp.Finger.Index, fp.FingerCurl.FullCurl, 1.0);

  // middle:
  raisedDescription.addCurl(fp.Finger.Middle, fp.FingerCurl.FullCurl, 1.0);

  // ring:
  raisedDescription.addCurl(fp.Finger.Ring, fp.FingerCurl.FullCurl, 1.0);

  // pinky:
  raisedDescription.addCurl(fp.Finger.Pinky, fp.FingerCurl.FullCurl, 1.0);


  const openDescription = new fp.GestureDescription('open_hand');

  // thumb:
  openDescription.addCurl(fp.Finger.Thumb, fp.FingerCurl.NoCurl, 1.0);

  // index:
  openDescription.addCurl(fp.Finger.Index, fp.FingerCurl.NoCurl, 1.0);

  // middle:
  openDescription.addCurl(fp.Finger.Middle, fp.FingerCurl.NoCurl, 1.0);

  // ring:
  openDescription.addCurl(fp.Finger.Ring, fp.FingerCurl.NoCurl, 1.0);

  // pinky:
  openDescription.addCurl(fp.Finger.Pinky, fp.FingerCurl.NoCurl, 1.0);



  const fingerDescription = new fp.GestureDescription('finger_up');

  // thumb:
  // raisedDescription.addCurl(fp.Finger.Thumb, fp.FingerCurl.FullCurl, 1.0);

  // index:
  fingerDescription.addCurl(fp.Finger.Index, fp.FingerCurl.NoCurl, 1.0);

  // middle:
  fingerDescription.addCurl(fp.Finger.Middle, fp.FingerCurl.FullCurl, 1.0);

  // ring:
  fingerDescription.addCurl(fp.Finger.Ring, fp.FingerCurl.FullCurl, 1.0);

  // pinky:
  fingerDescription.addCurl(fp.Finger.Pinky, fp.FingerCurl.FullCurl, 1.0);


      const knownGestures = [
        fp.Gestures.VictoryGesture,
        fp.Gestures.ThumbsUpGesture,
        raisedDescription,
        fingerDescription,
        openDescription
      ];
      const GE = new fp.GestureEstimator(knownGestures);


      // main estimation loop 
      function estimate_hands(detections, width, height){


        for(let i = 0; i < detections.multiHandLandmarks.length; i++) {

          landmarks = [];
          for(let j = 0; j < detections.multiHandLandmarks[0].length; j++){
            landmarks.push([detections.multiHandLandmarks[0][j].x * width, 
                            detections.multiHandLandmarks[0][j].y * height, 
                            detections.multiHandLandmarks[0][j].z])
          }

          min_score = 8;
          const est = GE.estimate(landmarks, min_score);
          const dic = {};

          const fp_estimator = new FingerPoseEstimator(dic);

          const fp_est = fp_estimator.estimate(landmarks);

          let poseData = [];
          for(let fingerIdx of fp.Finger.all) {
            poseData.push([
              fp.Finger.getName(fingerIdx),
              fp.FingerCurl.getName(fp_est.curls[fingerIdx]),
              fp.FingerDirection.getName(fp_est.directions[fingerIdx])
            ]);
          }
          
          // console.log(poseData);
          // console.log("tried to estimate gestures " + est.gestures.length);

          if(est.gestures.length > 0) {


            // find gesture with highest match score
            let result = est.gestures.reduce((p, c) => { 
              return (p.score > c.score) ? p : c;
            });
            const gestureStrings = {
                  'raised_fist': '‚úä',
                  'finger_up' : 'üëÜ',
                  'open_hand' : 'üñê',
            };

            if (result.name=='open_hand') {
                is_open_hand = true;
            }

            else{
              is_open_hand = false;
            }

             if (result.name=='finger_up') {
                is_finger_up = true;
            }

            else{
              is_finger_up = false;
            }

            // console.log(gestureStrings[result.name]);
            // console.log(result.score);
          }


        }

      };




var objToday = new Date(),
  weekday = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'),
  dayOfWeek = weekday[objToday.getDay()],
  domEnder = function() { var a = objToday; if (/1/.test(parseInt((a + "").charAt(0)))) return "th"; a = parseInt((a + "").charAt(1)); return 1 == a ? "st" : 2 == a ? "nd" : 3 == a ? "rd" : "th" }(),
  dayOfMonth = today + ( objToday.getDate() < 10) ? '0' + objToday.getDate() + domEnder : objToday.getDate() + domEnder,
  months = new Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'),
  curMonth = months[objToday.getMonth()],
  curYear = objToday.getFullYear();
  var today = dayOfWeek + " " + dayOfMonth + " of " + curMonth + ", " + curYear;

// document.getElementsByClassName('date')[0].textContent = today;


//colors button
const btn = document.getElementById('btn');
const btn_01 = document.getElementById('btn_01');
const btn_02 = document.getElementById('btn_02');
const btn_03 = document.getElementById('btn_03');
const btn_04 = document.getElementById('btn_04');
const btn_05 = document.getElementById('btn_05');
const btn_06 = document.getElementById('btn_06');
const btn_07 = document.getElementById('btn_07');

var color = "#F26945";

// let index = 0;
// var colors = ["#F26945", "#FAE80B", "#CF2133", "#0E8142", "#4D3292", "#2D63AF", "#000000", "#81592F"];
// btn.style.borderStyle = colors[index];
// // btn.style.backgroundColor = colors[index];
// btn.style.text = colors[index];

// btn.addEventListener('click', function onClick() {
//   index = index >= colors.length - 1 ? 0 : index + 1;
//   btn.style.backgroundColor = colors[index];
  
// });

btn.addEventListener('click', function onClick() {
  color = "#F26945";  
});

btn_01.addEventListener('click', function onClick() {
  color = "#FAE80B";  
});

btn_02.addEventListener('click', function onClick() {
  color = "#CF2133";  
});

btn_03.addEventListener('click', function onClick() {
  color = "#0E8142";  
});

btn_04.addEventListener('click', function onClick() {
  color = "#4D3292";  
});

btn_05.addEventListener('click', function onClick() {
  color = "#2D63AF";  
});

btn_06.addEventListener('click', function onClick() {
  color = "#81592F";  
});

btn_07.addEventListener('click', function onClick() {
  color = "#000000";  
});





//video  
let detections = {};
const videoElement = document.getElementsByClassName('input_video')[0];

function gotHands(results) {
  detections= results;
  // console.log(detections);
}

const hands = new Hands({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});


hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  hands.onResults(gotHands);

  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await hands.send({image: videoElement});
    },
    width: 320/1.4,
    height: 240/1.4
  });
  camera.start();


var px;
var py;
var lastX = 0;
var lastY = 0;
let pts = [];
var myColors = ["#F26945", "#FAE80B", "#CF2133", "#0E8142", "#4D3292"];
let canvas;
var line_count = 0;
var database;
var drawing = [];
var current_blob;

let eraseEnable = false;

let sketch = function(p){
  p.setup = function(){
    canvas = p.createCanvas(p.windowWidth,p.windowHeight);
    canvas.parent('canvascontainer');

    var uploadButton = p.select('#Submit');
    uploadButton.mousePressed(submitDraw);


    var uploadButton02 = p.select('#uploadButton');
    uploadButton02.mousePressed(uploadDrawing);

    var downloadButton = p.select('#downloadButton');
    downloadButton.mousePressed(downloadCanvas);

    var clearButton = p.select('#clearButton');
    clearButton.mousePressed(clearCanvas);

    p.background(255);

    const firebaseConfig = {
    apiKey: "AIzaSyC1cngA73ni9Oef-37GkDjksdnQJ48VLno",
    authDomain: "handsdrawing-5f3a9.firebaseapp.com",
    databaseURL: "https://handsdrawing-5f3a9-default-rtdb.firebaseio.com",
    projectId: "handsdrawing-5f3a9",
    storageBucket: "handsdrawing-5f3a9.appspot.com",
    messagingSenderId: "210592277963",
    appId: "1:210592277963:web:0809b3deda186aaebfc24e",
    measurementId: "G-2G046QY5BG"
  };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    database = firebase.database();
    ref = database.ref('drawing');

    
    ref.on('value', gotData);
  }


  $("#uploadButton").on("click", function() {
        // changeCursor = false;
        $(".save-overlay, .content-overlay, .modal").addClass("active_overlay");
        });
      

        $(".save-overlay__close, #Submit").on("click", function() {
          // changeCursor = true;
        $(".save-overlay, .content-overlay, .modal").removeClass("active_overlay");
  });

  function clearCanvas(){
    p.clear();
    p.background(255);
  }

  function downloadCanvas() {
    p.saveCanvas('BackToKindergarten', 'jpg');
  }

  
  function uploadDrawing(){
    // document.querySelector('#preview').innerHTML = 'loading...';
   

    let html_canvas = document.querySelector("#defaultCanvas0");
    html_canvas.toBlob(function(blob){
        current_blob = blob;
        var objectURL = URL.createObjectURL(current_blob);
        document.querySelector('#preview').innerHTML = '';
        var preview = document.createElement('span');
        document.querySelector('#preview').appendChild(preview);
        var img = document.createElement('img');
        img.src = objectURL;
        img.width = p.windowWidth/3.5;
        img.height = p.windowHeight/3.5;
        preview.appendChild(img);
  
    });
  }

  function submitDraw(){
      var storageRef = firebase.storage().ref();
      var element = document.getElementById("name_input");
      var text = element.value;
      var file_ref = storageRef.child('images/' + Math.floor(Math.random() * 1000));
      var uploadTask = file_ref.put(current_blob).then((snapshot) => {
        var url = file_ref.getDownloadURL().then((url) => {
        // Do something with the URL ...
        var ref = database.ref('drawing');
        var data = {
          name: text,
          url: url
        }
        var results = ref.push(data);
        // document.querySelector('#preview').innerHTML = '';
        // var preview = document.createElement('span', url);
        // document.querySelector('#preview').appendChild(preview);
        // var img = document.createElement('img');
        // img.src = url;
        // img.width = p.windowWidth/3.5;
        // img.height = p.windowHeight/3.5;
        // preview.appendChild(img);
        // console.log(url);
        }

      );
    });
  }


  function gotData(data){

    if (data == null) {
      return;
    }

    var data = data.val();

    if (data == null) {
      return;
    }
  }  

  //   var keys = Object.keys(data);
  //   ref = database.ref('drawing');
  //   document.querySelector('#preview').innerHTML = '';
  //   for (var i = 0; i< keys.length; i++) {
  //     // ref.child(keys[i]).remove();
  //     var key = keys;
  //     var new_url = url;
  //     new_url = data[key].url;
  //     var preview = document.createElement('span', url);
  //     document.querySelector('#preview').appendChild(preview);
  //     var img = document.createElement('img');
  //     img.src = url;
  //     img.width = p.windowWidth/3.5;
  //     img.height = p.windowHeight/3.5;
  //     preview.appendChild(img);
  //   }
  //  }

  function showDrawing(){
    var key = this.html();
    var ref = database.ref('drawing/' + key);
    ref.on('value', oneDrawing, errData);

    function oneDrawing(data){
      var dbdrawing = data.val();
      drawing = dbdrawing.drawing;
    }
  }

  p.draw = function(){
    
    if (detections != undefined) {
      if (detections.multiHandLandmarks != undefined) {
        if (is_draw) {
        
        p.drawHands();
        
        }
        if(detections.multiHandLandmarks.length > 0){
          estimate_hands(detections, p.width, p.height);  
        }
        if (is_open_hand) {
          is_draw = false;
          line_count = 0;
        }
        if (is_finger_up) {
          is_draw = true;
          $( "#on_start" ).hide();
        }
      }
    }  
  }



// p.drawHands = function(){
//   p.stroke(colors[index]);
//   p.strokeWeight(10);

//   for (var i =0; i<detections.multiHandLandmarks.length; i++) {
//     for (var j =0; j<detections.multiHandLandmarks[i].length; j++) {
      
//       let x = detections.multiHandLandmarks[i][j].x * p.width;
//       let y = detections.multiHandLandmarks[i][j].y * p.height;
//       let z = detections.multiHandLandmarks[i][j].z;

//       p.point(x, y, z);

//       }
//     }
//   }


// draw lines

p.drawHands = function(){
  p.stroke(color);
  p.strokeWeight(6);

  for (var i =0; i<detections.multiHandLandmarks.length; i++) {
    for (var j =0; j<detections.multiHandLandmarks[i].length; j++) {
      
      let x = (1- detections.multiHandLandmarks[i][j].x) * p.width;
      let y = detections.multiHandLandmarks[i][j].y * p.height;

      if(lastX==0 && lastY==0){
        lastX = x;
        lastY = y;
      }

      if(j==8){
        let d = p.dist(lastX, lastY, x, y);

// d<130
        if (true) {
          line_count++;
          if(line_count>2){
          p.line(lastX, lastY, x, y);
          drawing.push({x1:lastX, y1:lastY, x2: x, y2:y, color: color})
        }
          lastX = x;
          lastY = y;
        }
        else{
          lastX = 0;
          lastY = 0;
          // console.log(d);
        }    

      } 

      }
    }
  }
}
let myp5 = new p5(sketch);


</script>